<!DOCTYPE html>
<html lang="en" translate="no">
  <head>
    <meta charset="UTF-8" />
    <title>Flashcard Generator</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      body {
        margin: 0;
        background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 35%, #a18cd1 70%, #fbc2eb 100%);
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      }
    </style>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <!-- Simple text compression to keep share URLs shorter -->
    <script src="https://cdn.jsdelivr.net/npm/lz-string@1.5.0/libs/lz-string.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  </head>
  <body>
    <div id="root"></div>
    <script type="text/babel">
      const { useState, useEffect } = React;

      // Simple flashcard generator webapp
      function FlashcardApp() {
        const [spreadsheet, setSpreadsheet] = useState("");
        const [flashcards, setFlashcards] = useState([]);
        const [currentIndex, setCurrentIndex] = useState(0);
        const [showAnswer, setShowAnswer] = useState(false);
        const [isReversed, setIsReversed] = useState(false); // false: front->question, true: back->question
        const [sourceInfo, setSourceInfo] = useState("Paste CSV / tab text or load an .xlsx file.");
        const [showCreator, setShowCreator] = useState(true);
        const [shrinkScale, setShrinkScale] = useState(1.0); // For gradual shrinking during auto-advance
        const [randomMixCards, setRandomMixCards] = useState(true); // Checkbox for randomly shuffling card order (default: true)
        const [isMobile, setIsMobile] = useState(false); // For responsive tweaks
        const [cardOrderMode, setCardOrderMode] = useState("questionFirst"); // "questionFirst", "answerFirst", "randomizes"

        function shuffleArray(array) {
          const copy = [...array];
          for (let i = copy.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [copy[i], copy[j]] = [copy[j], copy[i]];
          }
          return copy;
        }

        function Step({ number, label, isActive, isDone, onClick }) {
          const isCompleted = isDone && !isActive;
          const circleStyle = {
            width: isActive ? 34 : 30,
            height: isActive ? 34 : 30,
            borderRadius: "50%",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            border: `2px solid ${isActive ? "#1f3c88" : isCompleted ? "#4caf50" : "#c5cee5"}`,
            background: isActive
              ? "#1f3c88"
              : isCompleted
              ? "#4caf50"
              : "#ffffff",
            color: isActive || isCompleted ? "#ffffff" : "#1f3c88",
            fontWeight: "bold",
            boxShadow: isActive ? "0 0 0 4px rgba(31,60,136,0.12)" : "none",
            transition: "all 0.18s ease",
          };
          const labelStyle = {
            marginTop: 6,
            padding: "0 0.6rem",
            fontSize: 12,
            color: isActive ? "#1f3c88" : isCompleted ? "#4caf50" : "#777",
            textAlign: "center",
            fontWeight: isActive ? 600 : 500,
            whiteSpace: "nowrap",
          };
          return (
            <div
              style={{
                display: "flex",
                flexDirection: "column",
                alignItems: "center",
                cursor: onClick ? "pointer" : "default",
                padding: "0.2rem 0.7rem",
                borderRadius: 999,
                backgroundColor: isActive ? "rgba(31,60,136,0.05)" : "transparent",
              }}
              onClick={onClick || undefined}
            >
              <div style={circleStyle}>{number}</div>
              <div style={labelStyle}>{label}</div>
            </div>
          );
        }

        function updateUrlFromSpreadsheet(text) {
          try {
            const raw = text || "";
            let hash = "";
            // Prefer compressed format when possible to keep URLs shorter.
            if (window.LZString && typeof window.LZString.compressToEncodedURIComponent === "function") {
              const compressed = window.LZString.compressToEncodedURIComponent(raw);
              if (compressed && compressed.length > 0) {
                hash = "lz=" + compressed;
              }
            }
            // Fallback: plain URI encoding (legacy format).
            if (!hash) {
              const encoded = encodeURIComponent(raw);
              if (encoded) {
                hash = "data=" + encoded;
              }
            }
            // Add cardOrderMode setting to URL (only if not default "questionFirst")
            if (hash && cardOrderMode !== "questionFirst") {
              hash += "&order=" + encodeURIComponent(cardOrderMode);
            } else if (cardOrderMode !== "questionFirst") {
              hash = "order=" + encodeURIComponent(cardOrderMode);
            }
            // Add randomMixCards setting to URL (only if false, since default is true)
            if (hash && !randomMixCards) {
              hash += "&mixCards=0";
            } else if (!randomMixCards) {
              hash = "mixCards=0";
            }
            window.location.hash = hash || "";
          } catch (e) {
            console.error("Failed to encode data into URL", e);
          }
        }

        function parseSpreadsheet(text) {
          const lines = text
            .split("\n")
            .map((line) => line.trim())
            .filter(Boolean);

          return lines
            .map((line) => {
              // Prefer explicit separators first: comma or tab
              let parts = line.split(/,|\t/).map((p) => p.trim()).filter(Boolean);

              // If we didn't get both sides, fall back to "columns" by spaces:
              // treat the last chunk as the answer and everything before as the question.
              if (parts.length < 2) {
                const tokens = line.split(/\s+/).filter(Boolean);
                if (tokens.length >= 2) {
                  const back = tokens[tokens.length - 1];
                  const front = tokens.slice(0, -1).join(" ");
                  parts = [front, back];
                }
              }

              return {
                front: parts[0] || "",
                back: parts[1] || "",
              };
            })
            .filter((card) => card.front && card.back);
        }

        // Track viewport size for simple mobile-friendly tweaks
        useEffect(() => {
          function handleResize() {
            try {
              setIsMobile(window.innerWidth <= 640);
            } catch {
              setIsMobile(false);
            }
          }
          handleResize();
          window.addEventListener("resize", handleResize);
          return () => window.removeEventListener("resize", handleResize);
        }, []);

        // On first load, try to restore from URL hash:
        // - New format:  #lz=<compressed text with LZString.compressToEncodedURIComponent>
        // - Legacy:      #data=<encodeURIComponent text>
        // - Also supports: &order=<mode> for card ordering mode, &mixCards=1 for random mixing
        useEffect(() => {
          try {
            const hash = window.location.hash || "";
            let loadedMode = "questionFirst";
            let shouldMixCards = hash.includes("mixCards=1");
            // Check for order mode
            const orderMatch = hash.match(/[&?]order=([^&]*)/);
            if (orderMatch && orderMatch[1]) {
              const mode = decodeURIComponent(orderMatch[1]);
              // Support legacy modes for backward compatibility
              if (mode === "keep" || mode === "cardOrder") {
                loadedMode = "questionFirst";
                setCardOrderMode("questionFirst");
              } else if (mode === "randomize") {
                // Legacy: randomize mode means randomizes (random side first)
                loadedMode = "randomizes";
                setCardOrderMode("randomizes");
              } else if (["answerFirst", "questionFirst", "randomizes"].includes(mode)) {
                loadedMode = mode;
                setCardOrderMode(mode);
              }
            }
            // Check for random mix cards setting (default to true if not specified)
            if (hash.includes("mixCards=0")) {
              shouldMixCards = false;
              setRandomMixCards(false);
            } else if (shouldMixCards || !hash.includes("mixCards=")) {
              // Default to true if not specified or explicitly set to 1
              shouldMixCards = true;
              setRandomMixCards(true);
            }
            // Extract and decode the data
            const match = hash.match(/^#?(lz|data)=([^&]*)/);
            if (match && match[2]) {
              const [, kind, payload] = match;
              let decoded = "";
              if (kind === "lz" && window.LZString && typeof window.LZString.decompressFromEncodedURIComponent === "function") {
                decoded = window.LZString.decompressFromEncodedURIComponent(payload) || "";
              } else {
                decoded = decodeURIComponent(payload);
              }
              setSpreadsheet(decoded);
              const parsedCards = parseSpreadsheet(decoded);
              // Shuffle if randomMixCards is enabled
              const cards = shouldMixCards ? shuffleArray(parsedCards) : parsedCards;
              setFlashcards(cards);
              if (cards.length > 0) {
                setCurrentIndex(0);
                // Set initial display based on order mode
                if (loadedMode === "answerFirst") {
                  setShowAnswer(true);
                  setIsReversed(false); // Show answer (back) side
                } else if (loadedMode === "randomizes") {
                  // Randomly pick which side shows first
                  const showAnswerFirst = Math.random() < 0.5;
                  setShowAnswer(showAnswerFirst);
                  setIsReversed(showAnswerFirst); // If showing answer, reverse the card
                } else {
                  // questionFirst (default)
                  setShowAnswer(false);
                  setIsReversed(false); // Show question (front) side
                }
                setSourceInfo(`Loaded ${cards.length} cards from URL`);
                // When opening from a shared link, go straight to the Play tab
                setShowCreator(false);
              }
            }
          } catch (e) {
            console.error("Failed to parse data from URL", e);
          }
        }, []);

        // Sync URL when cardOrderMode or randomMixCards changes (if we have flashcards)
        useEffect(() => {
          if (flashcards.length > 0 && spreadsheet) {
            updateUrlFromSpreadsheet(spreadsheet);
          }
        }, [cardOrderMode, randomMixCards]);

        // Parse first sheet of an uploaded XLSX file.
        // Robust: uses non-empty columns as "cells", first cell(s) = question, last cell = answer.
        function parseXlsxToFlashcards(workbook) {
          const sheetName = workbook.SheetNames[0];
          const sheet = workbook.Sheets[sheetName];
          const rows = XLSX.utils.sheet_to_json(sheet, { header: 1 });

          const cards = rows
            .map((row) => {
              if (!row || row.length === 0) return null;

              // Take all non-empty cells in the row
              const cells = row
                .map((cell) => (cell == null ? "" : cell.toString().trim()))
                .filter((v) => v.length > 0);

              // Need at least two non-empty cells to form a pair
              if (cells.length < 2) return null;

              // If we have 3+ cells, treat [0] + [1] as word + IPA, last as translation.
              // If we have exactly 2, treat first as "question" (can already contain IPA),
              // last as translation/answer.
              let front;
              let back;

              if (cells.length >= 3) {
                front = `${cells[0]}  ${cells[1]}`;
                back = cells[cells.length - 1];
              } else {
                front = cells[0];
                back = cells[1];
              }

              if (!front || !back) return null;

              return { front, back };
            })
            .filter(Boolean);

          return cards;
        }

        function handleXlsxChange(event) {
          const file = event.target.files && event.target.files[0];
          if (!file) return;

          const reader = new FileReader();
          reader.onload = function (e) {
            try {
              const data = new Uint8Array(e.target.result);
              const workbook = XLSX.read(data, { type: "array" });
              const parsedCards = parseXlsxToFlashcards(workbook);
              // Shuffle if randomMixCards is enabled
              const cards = randomMixCards ? shuffleArray(parsedCards) : parsedCards;
              if (cards.length > 0) {
                const text = cards
                  .map((card) => `${card.front}\t${card.back}`)
                  .join("\n");
                setSpreadsheet(text);
                setFlashcards(cards);
                setCurrentIndex(0);
                // Set initial display based on order mode
                if (cardOrderMode === "answerFirst") {
                  setShowAnswer(true);
                  setIsReversed(false); // Show answer (back) side
                } else if (cardOrderMode === "randomizes") {
                  // Randomly pick which side shows first
                  const showAnswerFirst = Math.random() < 0.5;
                  setShowAnswer(showAnswerFirst);
                  setIsReversed(showAnswerFirst); // If showing answer, reverse the card
                } else {
                  // questionFirst (default)
                  setShowAnswer(false);
                  setIsReversed(false); // Show question (front) side
                }
                updateUrlFromSpreadsheet(text);
                setSourceInfo(`Loaded ${cards.length} cards from "${file.name}"`);
                setShowCreator(false);
              } else {
                setFlashcards([]);
                setSpreadsheet("");
                updateUrlFromSpreadsheet("");
                setSourceInfo(
                  `No usable rows found in “${file.name}”. Make sure you have columns: word | IPA | translation.`
                );
              }
            } catch (err) {
              console.error("Failed to read XLSX file", err);
              setSourceInfo("Could not read that Excel file. Is it a valid .xlsx?");
            }
          };
          reader.readAsArrayBuffer(file);
        }

        const placeholderSample = "apple, jablko\ncar, auto";

        function handleGenerate() {
          const sourceText = (spreadsheet || "").trim().length === 0 ? placeholderSample : spreadsheet;
          if ((spreadsheet || "").trim().length === 0) {
            setSpreadsheet(placeholderSample);
          }
          const parsedCards = parseSpreadsheet(sourceText);
          // Shuffle if randomMixCards is enabled
          const cards = randomMixCards ? shuffleArray(parsedCards) : parsedCards;
          setFlashcards(cards);
          setCurrentIndex(0);
          // Set initial display based on order mode
          if (cardOrderMode === "answerFirst") {
            setShowAnswer(true);
            setIsReversed(false); // Show answer (back) side
          } else if (cardOrderMode === "randomizes") {
            // Randomly pick which side shows first
            const showAnswerFirst = Math.random() < 0.5;
            setShowAnswer(showAnswerFirst);
            setIsReversed(showAnswerFirst); // If showing answer, reverse the card
          } else {
            // questionFirst (default)
            setShowAnswer(false);
            setIsReversed(false); // Show question (front) side
          }
          updateUrlFromSpreadsheet(sourceText);
          if (cards.length > 0) {
            setSourceInfo(
              sourceText === placeholderSample
                ? `Generated ${cards.length} cards from sample text`
                : `Generated ${cards.length} cards from text`
            );
            setShowCreator(false);
          } else {
            setSourceInfo(
              "No valid pairs found. Use: word, translation OR word<TAB>translation per line."
            );
          }
        }

        function handleRestartWizard() {
          setShowCreator(true);
          setFlashcards([]);
          setCurrentIndex(0);
          setShowAnswer(false);
          setIsReversed(false);
          setSourceInfo("Paste CSV / tab text or load an .xlsx file.");
          updateUrlFromSpreadsheet("");
        }

        function handleShare() {
          try {
            // Ensure URL reflects current source
            updateUrlFromSpreadsheet(spreadsheet);
            const url = window.location.href;
            if (navigator.clipboard && navigator.clipboard.writeText) {
              navigator.clipboard.writeText(url).then(
                () => setSourceInfo("The URL copied!"),
                () => setSourceInfo("The URL copied!")
              );
            } else {
              setSourceInfo("The URL copied!");
            }
          } catch (e) {
            console.error("Share failed", e);
            setSourceInfo("The URL copied!");
          }
        }

        function handleNext() {
          if (flashcards.length > 0) {
            // Immediately show the new card (no delay)
            setShrinkScale(1.0); // Reset scale first
            setCurrentIndex((idx) => (idx + 1) % flashcards.length); // Change card
            // Set initial display based on order mode
            if (cardOrderMode === "answerFirst") {
              setShowAnswer(true);
              setIsReversed(false); // Show answer (back) side
            } else if (cardOrderMode === "randomizes") {
              // Randomly pick which side shows first
              const showAnswerFirst = Math.random() < 0.5;
              setShowAnswer(showAnswerFirst);
              setIsReversed(showAnswerFirst); // If showing answer, reverse the card
            } else {
              // questionFirst (default)
              setShowAnswer(false);
              setIsReversed(false); // Show question (front) side
            }
          }
        }

        function handlePrev() {
          if (flashcards.length > 0) {
            setShrinkScale(1.0); // Reset scale first
            setCurrentIndex((idx) => (idx - 1 + flashcards.length) % flashcards.length);
            // Set initial display based on order mode
            if (cardOrderMode === "answerFirst") {
              setShowAnswer(true);
              setIsReversed(false); // Show answer (back) side
            } else if (cardOrderMode === "randomizes") {
              // Randomly pick which side shows first
              const showAnswerFirst = Math.random() < 0.5;
              setShowAnswer(showAnswerFirst);
              setIsReversed(showAnswerFirst); // If showing answer, reverse the card
            } else {
              // questionFirst (default)
              setShowAnswer(false);
              setIsReversed(false); // Show question (front) side
            }
          }
        }

        function handleFlip() {
          setShowAnswer((s) => {
            if (!s) {
              // When showing answer, start shrinking
              setShrinkScale(1.0);
            } else {
              // When hiding answer, reset scale
              setShrinkScale(1.0);
            }
            return !s;
          });
        }

        // After revealing the answer, keep it visible for a while, then move to the next card.
        // Also gradually shrink the card during the last part of that time.
        useEffect(() => {
          if (!showAnswer || flashcards.length === 0) {
            setShrinkScale(1.0); // Reset scale when answer is hidden
            return;
          }

          const indexAtStart = currentIndex;
          const total = flashcards.length;
          const duration = 10000; // total: 10 seconds
          const shrinkDelay = 2000; // wait 2 seconds before starting shrink
          const shrinkDuration = duration - shrinkDelay; // 6 seconds of shrinking
          const startTime = Date.now();
          const startScale = 1.0;
          const endScale = 0.7; // Shrink to 70% of original size

          // Update scale smoothly over time
          const interval = setInterval(() => {
            const elapsed = Date.now() - startTime;
            if (elapsed <= shrinkDelay) {
              // First phase: keep full size
              setShrinkScale(1.0);
            } else {
              const shrinkElapsed = elapsed - shrinkDelay;
              const progress = Math.min(shrinkElapsed / shrinkDuration, 1.0);
              const scale = startScale - (startScale - endScale) * progress;
              setShrinkScale(scale);
            }
          }, 50); // Update every 50ms for smooth animation

          const timer = setTimeout(() => {
            // Only auto-advance if we're still on the same card and still showing the answer
            setCurrentIndex((idx) => {
              if (idx !== indexAtStart) return idx;
              return (idx + 1) % total;
            });
            // Set initial display for next card based on order mode
            if (cardOrderMode === "answerFirst") {
              setShowAnswer(true);
              setIsReversed(false); // Show answer (back) side
            } else if (cardOrderMode === "randomizes") {
              // Randomly pick which side shows first
              const showAnswerFirst = Math.random() < 0.5;
              setShowAnswer(showAnswerFirst);
              setIsReversed(showAnswerFirst); // If showing answer, reverse the card
            } else {
              // questionFirst (default)
              setShowAnswer(false);
              setIsReversed(false); // Show question (front) side
            }
            setShrinkScale(1.0); // Reset scale for next card
          }, duration);

          return () => {
            clearTimeout(timer);
            clearInterval(interval);
          };
        }, [showAnswer, currentIndex, flashcards.length, cardOrderMode]);

        // Highlight sequences of double letters (ll, tt, etc.) to draw attention.
        function highlightDoubleLetters(text) {
          if (!text) return "";
          const result = [];
          const regex = /(.)\1+/gi;
          let lastIndex = 0;
          let match;
          while ((match = regex.exec(text)) !== null) {
            const [sequence] = match;
            const start = match.index;
            if (start > lastIndex) {
              result.push(text.slice(lastIndex, start));
            }
            result.push(
              <span style={{ backgroundColor: "#fff3cd", padding: "0 2px" }} key={result.length}>
                {sequence}
              </span>
            );
            lastIndex = start + sequence.length;
          }
          if (lastIndex < text.length) {
            result.push(text.slice(lastIndex));
          }
          return result;
        }

        // Determine which step is active for the wizard header (2 steps: Create Flashcard, Play & Share)
        const hasCards = flashcards.length > 0;
        let currentStep = 1;
        if (showCreator) {
          currentStep = 1; // Create Flashcard
        } else if (hasCards) {
          currentStep = 2; // Play & Share
        }

        const stepSubtitle =
          currentStep === 1
            ? "Create new flashcards from your spreadsheet or Excel file."
            : "Your game is ready! Click to share or start playing.";

        return (
          <div
            style={{
              maxWidth: isMobile ? 520 : 900,
              margin: isMobile ? "1.25rem auto" : "2.25rem auto",
              padding: isMobile ? "1.25rem 1rem 1.75rem" : "1.75rem 1.5rem 2.25rem",
              background: "#ffffff",
              borderRadius: 24,
              boxShadow: "0 18px 40px rgba(0,0,0,0.18)",
              boxSizing: "border-box",
            }}
          >
            <h2
              style={{
                marginTop: 0,
                marginBottom: "0.5rem",
                color: "#1f3c88",
                fontSize: isMobile ? "1.35rem" : "1.6rem",
                textAlign: isMobile ? "center" : "left",
              }}
            >
              Flashcard game generator
            </h2>
            <p
              style={{
                marginTop: 0,
                marginBottom: "1.5rem",
                fontSize: "0.9rem",
                color: "#46546b",
                textAlign: isMobile ? "center" : "left",
              }}
            >
              {stepSubtitle}
            </p>

            <div
                  style={{
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "space-between",
                    marginBottom: "1.25rem",
                    columnGap: 16,
                    rowGap: 10,
                    flexWrap: "wrap",
                  }}
                >
              <Step
                    number={1}
                    label="Create Flashcard"
                    isActive={currentStep === 1}
                    isDone={currentStep > 1}
                    onClick={handleRestartWizard}
              />
              <div
                    style={{
                      flex: 1,
                      height: 3,
                      minWidth: isMobile ? 40 : 80,
                      borderRadius: 999,
                      background:
                        currentStep > 1
                          ? "linear-gradient(to right,#1f3c88 0%,#4caf50 100%)"
                          : "linear-gradient(to right,#1f3c88 0%,#dde3f5 60%,#dde3f5 100%)",
                    }}
              />
              <Step
                    number={2}
                    label="Play & Share"
                    isActive={currentStep === 2}
                    isDone={false}
              />
            </div>
            <p style={{ fontSize: "0.86rem", color: "#777", marginBottom: "1rem" }}>
              {sourceInfo}
            </p>

            {showCreator ? (
              <div
                style={{
                  background: "#f7f9fc",
                  border: "2px solid #ccc",
                  borderRadius: 16,
                  padding: "1rem",
                  marginBottom: "1.5rem",
                }}
              >
                <p>
                  Paste or type your spreadsheet here using CSV or tab, or upload an Excel file:
                  <br />
                  <small>
                    Format: <code>hello, ahoj</code> (one pair per line)
                  </small>
                </p>
                <label style={{ display: "block", margin: "0.5rem 0" }}>
                  <strong>1. Load Excel (.xlsx) file</strong>
                  <br />
                  <input type="file" accept=".xlsx" onChange={handleXlsxChange} />
                </label>

                <hr style={{ margin: "1rem 0" }} />

                <p style={{ marginTop: "0.5rem" }}>
                  <strong>2. Or paste CSV / tab-separated text</strong>
                </p>
                <textarea
                  rows={8}
                  cols={40}
                  value={spreadsheet}
                  onChange={(e) => setSpreadsheet(e.target.value)}
                  placeholder={"apple, jablko\ncar, auto"}
                  style={{ width: "100%", fontFamily: "monospace", fontSize: "1rem" }}
                ></textarea>
                <div style={{ margin: "1rem 0" }}>
                  <label style={{ display: "flex", alignItems: "center", gap: "0.5rem", marginBottom: "0.75rem" }}>
                    <input
                      type="checkbox"
                      checked={randomMixCards}
                      onChange={(e) => setRandomMixCards(e.target.checked)}
                      style={{ width: "18px", height: "18px", cursor: "pointer" }}
                    />
                    <span style={{ fontSize: "0.95rem" }}>Randomly mix cards</span>
                  </label>
                  <label style={{ display: "block", marginBottom: "0.5rem" }}>
                    <span style={{ fontSize: "0.95rem", display: "block", marginBottom: "0.25rem" }}>Card order:</span>
                    <select
                      value={cardOrderMode}
                      onChange={(e) => setCardOrderMode(e.target.value)}
                      style={{
                        width: "100%",
                        padding: "0.5rem",
                        borderRadius: "8px",
                        border: "1px solid #ccc",
                        fontSize: "0.95rem",
                        cursor: "pointer",
                        fontFamily: "inherit",
                      }}
                    >
                      <option value="questionFirst">Question first</option>
                      <option value="answerFirst">Answer first</option>
                      <option value="randomizes">Randomizes</option>
                    </select>
                  </label>
                </div>
                <div style={{ margin: "1rem 0", display: "flex", gap: "0.75rem" }}>
                  <button
                    type="button"
                    onClick={() => {
                      setSpreadsheet("");
                      setFlashcards([]);
                      setCurrentIndex(0);
                      setShowAnswer(false);
                      setIsReversed(false);
                      setSourceInfo("Inputs cleared. Paste CSV / tab text or load an .xlsx file.");
                      updateUrlFromSpreadsheet("");
                    }}
                    style={{
                      padding: "0.5rem 1.25rem",
                      borderRadius: 999,
                      border: "1px solid #ccc",
                      background: "#f2f2f2",
                      color: "#333",
                      cursor: "pointer",
                    }}
                  >
                    Clear inputs
                  </button>
                  <button
                    type="button"
                    onClick={handleGenerate}
                    style={{
                      padding: "0.5rem 1.5rem",
                      borderRadius: 999,
                      border: "none",
                      background: "#1f3c88",
                      color: "#ffffff",
                      fontWeight: "600",
                      cursor: "pointer",
                      boxShadow: "0 3px 8px rgba(0,0,0,0.18)",
                    }}
                  >
                    Generate flashcards
                  </button>
                </div>
              </div>
            ) : (
              <div
                style={{
                  borderRadius: 30,
                  padding: "1.5rem",
                  marginBottom: "1.5rem",
                  display: "flex",
                  justifyContent: "space-between",
                  alignItems: "center",
                }}
              >
                <div style={{ flex: 1,  }}>
                  <h2>Your flashcards game</h2>
                </div>
                <button
                  onClick={handleShare}
                  style={{
                    borderRadius: 999,
                    padding: "0.5rem 1.2rem",
                    border: "2px solid #333",
                    background: "white",
                    cursor: "pointer",
                    fontWeight: "bold",
                    marginLeft: "1rem",
                  }}
                >
                  share
                </button>
              </div>
            )}

            {currentStep >= 2 && flashcards.length > 0 && (
              <div>
                {(() => {
                  const card = flashcards[currentIndex];
                  const question = isReversed ? card.back : card.front;
                  const answer = isReversed ? card.front : card.back;
                  return (
                <div
                  style={{
                    position: "relative",
                    borderRadius: 24,
                    border: "2px solid #ff6fb1",
                    minHeight: 140,
                    padding: "1.5rem 2rem",
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    fontSize: "2rem",
                    background:
                      "radial-gradient(circle at top left, #fff7f9 0%, #f7f9ff 45%, #f2f6ff 100%)",
                    cursor: "pointer",
                    marginBottom: 20,
                    boxShadow: "0 14px 30px rgba(0,0,0,0.12)",
                    transition:
                      "transform 0.25s ease, box-shadow 0.18s ease, opacity 0.25s ease",
                    transform: showAnswer
                      ? `rotateY(6deg) scale(${0.97 * shrinkScale})`
                      : "rotateY(-4deg) scale(1)",
                    opacity: showAnswer ? 0.9 * shrinkScale : 1,
                  }}
                  onMouseEnter={(e) => {
                    if (!showAnswer) {
                      e.currentTarget.style.transform = "rotateY(-4deg) translateY(-3px)";
                      e.currentTarget.style.boxShadow = "0 18px 40px rgba(0,0,0,0.18)";
                    }
                  }}
                  onMouseLeave={(e) => {
                    if (!showAnswer) {
                      e.currentTarget.style.transform = "rotateY(-4deg) scale(1)";
                      e.currentTarget.style.boxShadow = "0 14px 30px rgba(0,0,0,0.12)";
                    }
                  }}
                  onClick={handleFlip}
                  title="Click to flip"
                >
                  <div
                    style={{
                      position: "absolute",
                      top: 12,
                      right: 18,
                      padding: "0.1rem 0.7rem",
                      borderRadius: 999,
                      fontSize: "0.7rem",
                      letterSpacing: "0.06em",
                      textTransform: "uppercase",
                      backgroundColor: showAnswer ? "#1f3c88" : "#ffb347",
                      color: "#ffffff",
                      boxShadow: "0 2px 6px rgba(0,0,0,0.18)",
                    }}
                  >
                    {showAnswer ? "Answer" : "Question"}
                  </div>
                  <div style={{ textAlign: "center", lineHeight: 1.3 }} translate="no">
                    {showAnswer
                      ? highlightDoubleLetters(answer)
                      : highlightDoubleLetters(question)}
                  </div>
                </div>
                  );
                })()}
                <div>
                  <button onClick={handlePrev}>&larr; Prev</button>
                  <span style={{ margin: "0 1rem" }}>
                    Card {currentIndex + 1} / {flashcards.length}
                  </span>
                  <button onClick={handleNext}>Next &rarr;</button>
                </div>
                <p>
                  <button onClick={handleFlip}>
                    {showAnswer ? "Show Question" : "Show Answer"}
                  </button>
                </p>
              </div>
            )}
          </div>
        );
      }

      const rootElement = document.getElementById("root");
      const root = ReactDOM.createRoot(rootElement);
      root.render(<FlashcardApp />);
    </script>
  </body>
</html>
